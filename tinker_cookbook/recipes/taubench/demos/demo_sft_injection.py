#!/usr/bin/env python3
"""
Demo script showing SFT dataset ask_sonnet injection.

No API calls needed - just shows how messages are transformed.

Usage:
    uv run python -m tinker_cookbook.recipes.taubench.demo_sft_injection
"""

import json
import random

from tinker_cookbook.recipes.taubench.components import (
    AskSonnetMode,
    get_ask_sonnet_renderer,
)
from tinker_cookbook.recipes.taubench.sft_dataset import (
    _inject_ask_sonnet_calls,
    _generate_advice_for_action,
)
from tinker_cookbook.renderers import ToolCall


def print_separator(title: str):
    print("\n" + "=" * 80)
    print(title)
    print("=" * 80)


def print_messages(messages: list[dict], title: str = "Messages"):
    """Pretty print messages."""
    print(f"\n--- {title} ({len(messages)} messages) ---")
    for i, msg in enumerate(messages):
        role = msg.get("role", "?")
        content = msg.get("content", "")
        tool_calls = msg.get("tool_calls", [])
        tool_call_id = msg.get("tool_call_id", "")

        print(f"\n[{i}] {role.upper()}" + (f" (tool_call_id={tool_call_id})" if tool_call_id else ""))

        if tool_calls:
            for tc in tool_calls:
                if hasattr(tc, 'function'):
                    print(f"    TOOL_CALL: {tc.function.name}({tc.function.arguments})")
                else:
                    name = tc.get("name", tc.get("function", {}).get("name", "?"))
                    args = tc.get("arguments", tc.get("function", {}).get("arguments", {}))
                    print(f"    TOOL_CALL: {name}({args})")

        if content:
            display_content = content[:500] + "..." if len(content) > 500 else content
            print(f"    {display_content}")


def main():
    print_separator("SFT DATASET ASK_SONNET INJECTION DEMO")

    # Create sample conversation (simulating tau2 data)
    # NOTE: In tau2, assistant messages can have BOTH content AND tool_calls in the same message
    original_messages = [
        {"role": "system", "content": "You are a helpful retail assistant."},
        {"role": "user", "content": "Hi, I'd like to cancel my order #12345."},
        # First assistant turn - greeting + tool call in SAME message (can be injected)
        {
            "role": "assistant",
            "content": "Hello! I'd be happy to help you cancel your order. Let me look that up for you.",
            "tool_calls": [
                ToolCall(function=ToolCall.FunctionBody(name="get_order_details", arguments='{"order_id": "12345"}'))
            ]
        },
        {"role": "tool", "content": '{"order_id": "12345", "status": "pending", "items": ["Widget A"]}', "tool_call_id": "call_1"},
        {"role": "user", "content": "Yes, please cancel it."},
        # Second assistant turn - tool call only (can be injected)
        {
            "role": "assistant",
            "content": "",
            "tool_calls": [
                ToolCall(function=ToolCall.FunctionBody(name="cancel_order", arguments='{"order_id": "12345"}'))
            ]
        },
        {"role": "tool", "content": '{"status": "cancelled"}', "tool_call_id": "call_2"},
        {"role": "assistant", "content": "Done! Your order #12345 has been cancelled. Is there anything else I can help you with?"},
    ]

    print_messages(original_messages, "ORIGINAL CONVERSATION (no injection)")

    print_separator("INJECTION WITH 100% RATE")
    print("""
Note: First assistant turn is NEVER injected (agent should greet directly).
Only subsequent assistant turns can be injected.

The injection format is IDENTICAL for both DIRECT and CONDITIONING modes:
  [assistant] ask_sonnet tool call
  [tool] [Sonnet's Advice]: <original action content>
  [assistant] <original action>  (policy learns to follow advice)
""")

    # Inject with 100% rate
    injected = _inject_ask_sonnet_calls(
        [m.copy() for m in original_messages],
        injection_rate=1.0,
        rng=random.Random(42),
        mode=AskSonnetMode.CONDITIONING,  # Same format for both modes
    )
    print_messages(injected, "AFTER INJECTION (100% rate)")

    print_separator("INJECTION WITH 50% RATE (random)")
    injected_50 = _inject_ask_sonnet_calls(
        [m.copy() for m in original_messages],
        injection_rate=0.5,
        rng=random.Random(123),
        mode=AskSonnetMode.CONDITIONING,
    )
    print_messages(injected_50, "AFTER INJECTION (50% rate)")

    print_separator("GENERATED ADVICE EXAMPLES")
    print("\nThe advice is generated by copying the original assistant action:")

    for i, msg in enumerate(original_messages):
        if msg["role"] == "assistant":
            advice = _generate_advice_for_action(msg)
            print(f"\n--- Original message {i} ---")
            print(f"Content: {msg.get('content', '')[:100]}")
            if msg.get("tool_calls"):
                for tc in msg["tool_calls"]:
                    print(f"Tool call: {tc.function.name}({tc.function.arguments})")
            print(f"\n--- Generated advice ---")
            print(advice[:300] + "..." if len(advice) > 300 else advice)

    print_separator("KEY POINTS")
    print("""
1. First assistant turn is NEVER injected (agent greets directly)

2. SFT format is IDENTICAL for DIRECT and CONDITIONING modes:
   - ask_sonnet call
   - [Sonnet's Advice]: <original action>
   - <original action> (as followup)

3. The difference between modes is ONLY at inference time:
   - DIRECT: Sonnet's action is copied and sent to tau2 immediately
   - CONDITIONING: Qwen sees advice, produces its own followup, then sent to tau2

4. Advice is the FULL original action (text + tool calls in <tool_call> format)
""")


if __name__ == "__main__":
    main()
